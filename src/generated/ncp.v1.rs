// This file is @generated by prost-build.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Probe {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub capabilities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint32, tag = "4")]
    pub keepalive_seconds: u32,
    #[prost(string, tag = "5")]
    pub client_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Established {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub capabilities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub server_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileMeta {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub size: u64,
    #[prost(bool, tag = "3")]
    pub is_dir: bool,
    /// as POSIX octal, e.g. 0o644 => 420
    #[prost(uint32, tag = "4")]
    pub mode: u32,
    #[prost(message, optional, tag = "5")]
    pub mtime: ::core::option::Option<::prost_types::Timestamp>,
    /// "sha256", "xxhash64", etc.
    #[prost(string, tag = "6")]
    pub checksum_alg: ::prost::alloc::string::String,
    /// raw bytes (not hex)
    #[prost(bytes = "vec", tag = "7")]
    pub checksum: ::prost::alloc::vec::Vec<u8>,
    #[prost(map = "string, string", tag = "8")]
    pub attrs: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Meta {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub file: ::core::option::Option<FileMeta>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PreflightOk {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub destination_exists: bool,
    #[prost(uint64, tag = "3")]
    pub available_space: u64,
    #[prost(string, tag = "4")]
    pub temp_path: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PreflightFail {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(enumeration = "ErrorCode", tag = "2")]
    pub code: i32,
    #[prost(string, tag = "3")]
    pub reason: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TransferStart {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(enumeration = "TransferMode", tag = "2")]
    pub mode: i32,
    #[prost(uint64, tag = "3")]
    pub file_size: u64,
    /// for chunked mode
    #[prost(uint32, tag = "4")]
    pub chunk_size: u32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TransferResult {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub ok: bool,
    #[prost(enumeration = "ErrorCode", tag = "3")]
    pub code: i32,
    #[prost(string, tag = "4")]
    pub reason: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "5")]
    pub checksum: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "6")]
    pub received_bytes: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Heartbeat {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub seq: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Error {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(enumeration = "ErrorCode", tag = "2")]
    pub code: i32,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OffsetReport {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    /// used for resume negotiation
    #[prost(uint64, tag = "2")]
    pub received_bytes: u64,
    /// optional per-chunk checksums
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub chunk_checksums: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResumeRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub offset: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Capability {
    /// e.g., "checksum:sha256", "resume", "tls", "compress:gzip"
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ErrorCode {
    ErrorUnknown = 0,
    ErrProtocol = 1,
    ErrNoSpace = 2,
    ErrPermission = 3,
    ErrChecksum = 4,
    ErrTimeout = 5,
    ErrAuth = 6,
    ErrInvalidArg = 7,
    ErrResumeNotSupported = 8,
    ErrUnexpectedEof = 9,
}
impl ErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ErrorUnknown => "ERROR_UNKNOWN",
            Self::ErrProtocol => "ERR_PROTOCOL",
            Self::ErrNoSpace => "ERR_NO_SPACE",
            Self::ErrPermission => "ERR_PERMISSION",
            Self::ErrChecksum => "ERR_CHECKSUM",
            Self::ErrTimeout => "ERR_TIMEOUT",
            Self::ErrAuth => "ERR_AUTH",
            Self::ErrInvalidArg => "ERR_INVALID_ARG",
            Self::ErrResumeNotSupported => "ERR_RESUME_NOT_SUPPORTED",
            Self::ErrUnexpectedEof => "ERR_UNEXPECTED_EOF",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ERROR_UNKNOWN" => Some(Self::ErrorUnknown),
            "ERR_PROTOCOL" => Some(Self::ErrProtocol),
            "ERR_NO_SPACE" => Some(Self::ErrNoSpace),
            "ERR_PERMISSION" => Some(Self::ErrPermission),
            "ERR_CHECKSUM" => Some(Self::ErrChecksum),
            "ERR_TIMEOUT" => Some(Self::ErrTimeout),
            "ERR_AUTH" => Some(Self::ErrAuth),
            "ERR_INVALID_ARG" => Some(Self::ErrInvalidArg),
            "ERR_RESUME_NOT_SUPPORTED" => Some(Self::ErrResumeNotSupported),
            "ERR_UNEXPECTED_EOF" => Some(Self::ErrUnexpectedEof),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TransferMode {
    TransferRaw = 0,
    TransferChunked = 1,
}
impl TransferMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TransferRaw => "TRANSFER_RAW",
            Self::TransferChunked => "TRANSFER_CHUNKED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRANSFER_RAW" => Some(Self::TransferRaw),
            "TRANSFER_CHUNKED" => Some(Self::TransferChunked),
            _ => None,
        }
    }
}
